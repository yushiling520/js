<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>javascript core</title>
</head>
<body>
	<script type="text/javascript">
		//ECMASript是一门高度抽象的面向对象的语言   javascript是ECMAscript的一个实现  

		/*var a = {
			x:10,
			calculate:function(z){
				return this.x + this.y + z;
			}
		};//this在这个继承机制中，仍然指向它属于的对象而不是从原型链上找到相应属性时它所属于的对象

		var b = {
			y:20,
			__proto__:a
		};

		var c = {
			y:30,
			__proto__:a
		};
		console.log(b.calculate(10));
		console.log(c.calculate(20))*/

		//如果一个对象的prototype没有显示的声明或者定义过，那么__proto__的默认值就是object.prototype而object.prototype也会有一个__proto__ 就是原型链的终点，设置为null

		//执行上下文栈
		//ECMAScript中的代码有三种类型 global function eval  每一种代码的执行都需要依赖自身的上下文 global的上下文可能涵盖着很多的function和eval实例 function eval执行的时候也会进入进行计算



		//激活其他上下文的某个上下文被称为调用者(caller) 被激活的上下文称为被调用者(callee)  当一个caller激活一个callee，那么这个caller就会暂停它自身的执行，然后将控制权交给这个它调用的callee，于是这个callee就进入了堆栈，称为进行中的上下文，当这个callee的上下文结束的时候，会将控制权再次交给它的caller，然后caller会在刚才继续暂停的地方继续执行，这个caller结束后，会继续的触发其他的上下文 一个callee可以通过return 或者抛出异常来结束自身的上下文


		//执行上下文可以抽象的理解为object ，每一个执行上下文都有一系列的属性（上下文状态） 主要 变量对象 this指针 作用链域


		//变量对象（variable object）是与执行上下文相关的数据作用域  它是与上下文相关联的特殊对象，用于存储被定义在上下文中的变量和函数声明


		//在ECMAScript中，仅有函数能创建新的作用域  eval是魔鬼 eval会创建一个新的执行上下文（eval创建的），并且能访问全局变量对象和调用者的变量对象


		//在函数的上下文中，变量对象被表示成活动对象（activation object）

		//当函数被调用者激活的时候，这个特殊的活动对象就被创建了，活动对象在函数上下文中作为变量对象使用（函数的变量对象基础上增加参数映射表arguments）


		//作用链域是一个对象列表，用来检索上下文代码中出现的标识符

		//作用链域的原理和原型链的原理很类似，如果这个变量在自己的作用域中没有，那么它会去寻找父级的，直至最顶级

		//标识符可以理解为变量名称，函数声明，普通参数  当一个函数需要引用一个在自身的函数体内没有声明的变量的时候（也不是某个参数的名字），那么这个变量就可以称为自由变量，我们搜寻这些自由变量的时候就需要用到作用链域

		//一般情况下，一个作用链域包含父级的变量对象，函数自身的变量对象和活动对象

		//闭包
		//当需要从外部函数返回内部函数以用来将来调用的时候，内部函数在创建的时候需要将外部上下文中中变量存储进[[scope]]属性中，当函数被激活的时候，它的上下文的作用链域变现为活动对象 + [[scope]] 保存的外部作用域用于将来函数激活的时候变量的查找

		//使用静态的作用域是闭包的一个强制性要求 给出闭包的一个定义： 闭包是一系列的代码块（ECMAscript中是函数）并且静态的保存了父级的静态作用域，通过这些保存的作用域来搜寻函数中的静态变量

		/*var x = 10;

		function foo() {
			console.log(x);
		}


		(function(a){
			var x = 20;

			a();//10
		}(foo));
*/  
		//这里存在着一个问题就是闭包中保存的静态作用域会存在共享的问题，一个变量的变化会影响另一个闭包。


		//this是与执行上下文相关的对象，可以称它为执行上下文对象，this是执行上下文环境的一个属性，而不是某个变量对象的属性 因此当你在代码中使用this的时候，this的值就直接从上下文中获取了而不会从作用链域中查找，this的值只取决于进入上下文的情况

		//在全局上下文中 this指的是全局这个对象 

		/*var x = 10;
		console.log(x);
		console.log(this.x);*/


		//在函数上下文中，this会根据每次函数的调用不同而成为不同的值，this会每一次由caller提供















	</script>
</body>
</html>