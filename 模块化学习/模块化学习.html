<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>模块化学习</title>
</head>

<body>
	
	<script src="scripts/require.js" data-main="scripts/main"></script>
	
	<script type="text/javascript">
		/*var module = (function(){
			var a = 1;

			function f1() {
				console.log(1);
			}

			return {
				fn:f1
			}
		})();


		module.fn();*/

		//CommonJS  1定义模块 一个单独的文件就是一个模块  每一个模块都是一个单独的作用域   2 模块输出 module.exports 3 加载模块 读取文件并执行 返回文件的module.exports对象


		//通过require加载模块  require是同步的   浏览器脚步异步加载     浏览器端实现模块的思路

		//AMD  异步模块定义  浏览器端模块化开发的规范  由于javascript不原生支持使用AMD要使用相应的库函数(require.js)
		//require.js 解决的问题 1 被依赖的文件要早于依赖它的文件加载到浏览器 2 js加载的时候会停止页面渲染，加载文件越多，页面失去相应的时间越长

		
 		//require 的define函数定义模块  参数 define(id?,dependencies?,factory)  可选id 用于定义模块的标示符 没提供脚本文件的名字 2 dependencies 当前模块依赖的模块名称的数组 3 工厂方法 如果是函数 只执行一次 如果是对象 该对象是模块的输出值

 		//require 的require方法 require([dependencies],function(){}) 在页面中使用require加载模块 第一个参数是依赖的模块 第二个参数是当依赖模块加载完毕后执行的回调函数


 		/*require(['myModule'],function(my){
 			my.say();
 		})*/

		//CMD  通用模块定义 CMD 使用Sea.js实现  模块在定义方式和模块加载时机上不同   Sea.js推崇一个文件一个模块 所以使用文件名作为模块id  推崇依赖就近 经常在factory中写依赖 
		//define   define(id?,deps?,factory)   factory中有三个参数  (require,exports,module)  require是一个方法 接收模块标示作为唯一参数 用来获取其他模块提供的接口  exports用于向外提供模块接口 module是一个对象 上面存储了当前模块相关联的一些属性和方法 

	</script>

</body>
</html>